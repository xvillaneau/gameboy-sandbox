
include "hardware.inc"


SECTION "Header", ROM0[$0000]
    ; Mostly blank space reserved for someday

    ; rst $00
    ds $08 - @, $00
    ; rst $08
    ds $10 - @, $00
    ; rst $10
    ds $18 - @, $00
    ; rst $18
    ds $20 - @, $00
    ; rst $20
    ds $28 - @, $00
    ; rst $28
    ds $30 - @, $00
    ; rst $30
    ds $38 - @, $00
    ; rst $38
    ds $40 - @, $00

    ; V-Blank interrupt
    reti
    ds $48 - @, $00

    ; LCDC interrupt
    reti
    ds $50 - @, $00

    ; Timer interrupt
    reti
    ds $58 - @, $00

    ; Serial Com interrupt
    reti
    ds $60 - @, $00

    ; Joypad interrupt
    reti
    ds $0100 - @, $00

EntryPoint:
    nop
    jp Init
    ; Make space for ROM header
    ; Will be generated by rgbfix at the end
    ds $0150 - @, $00


SECTION "Main", ROM0

Init:
    di
._sync
    ; Wait for the vertical blanking interval so that we can disable the LCD.
    ldh a, [rLY]
    cp 144              ; Wait for first frame to draw
    jr c, ._sync        ; carry unset => V-Blank started

    xor a
    ldh [rLCDC], a      ; Disable LCD Controller to access VRAM

    call InitSound

    ; Core loop of the program. All this does is wait for the next interrupt.
    ld a, LCDCF_ON
    ldh [rLCDC], a

    ld a, 1
    ldh [rIE], a        ; Enable VBlank interrupts handling
    ei                  ; Enable interrupts

.loop:
    halt                ; Stop CPU until next interupt
    ; There needs to be a NOP after HALT, rgbasm does that for us
    call ReadInput
    call PlaySound
    jr .loop            ; Loop forever


; Reset all sound settings
InitSound:
    ; Disable then re-enable sound. This resets all sound registers
    xor a
    ldh [rNR52], a
    ld a, AUDENA_ON
    ldh [rNR52], a

    ; Copy the wave pattern to 
    ld hl, SINE_WAVE
    ld c, _AUD3WAVERAM & $ff
    ld b, 16
.wave_copy_loop
    ld a, [hli]
    ldh [c], a
    inc c
    dec b
    jr nz, .wave_copy_loop

    ; Configure global sound options:
    ld a, $ff           ; Enable all channels and terminals
    ldh [rNR51], a
    ld a, $77           ; Both terminals at max volume
    ld [rNR50], a
    ret

SINE_WAVE:
    db $89, $ac, $de, $ef, $ff, $ee, $dc, $a9
    db $86, $53, $21, $10, $00, $11, $23, $56
.end

; Play sound on input
PlaySound:
    ldh a, [hINPUT.up]
    ld b, a

    and a, INPUT_SELECT
    jr z, .play_channel_1
    ; Press select -> stop all sounds NOW
    call InitSound
    ret

.play_channel_1
    ; Left => Channel 1 tone with some frequency shift
    ld a, b
    and a, INPUT_LEFT
    jr z, .play_channel_2

    DEF CH1_SWEEP_TIME   EQU %101  ; 1 step = 39.1ms (5/128 Hz)
    DEF CH1_SWEEP_SHIFT  EQU %111  ; -1/128th freq/shift
    DEF CH1_ENV_INIT     EQU 15    ; Max volume
    DEF CH1_ENV_STEP     EQU 5     ; 1 step = 78.1ms (5/64 Hz)
    DEF CH1_FREQ         EQU 1750  ; 131072 / (2048 - 1750) = 440Hz

    ; Frequency sweep
    ld a, (CH1_SWEEP_TIME << 4) + AUD1SWEEP_DOWN + CH1_SWEEP_SHIFT
    ld [rNR10], a
    ; Wave pattern duty
    ld a, AUDLEN_DUTY_50
    ldh [rNR11], a
    ; Volume envelope
    ld a, (CH1_ENV_INIT << 4) + AUDENV_DOWN + CH1_ENV_STEP
    ldh [rNR12], a
    ; Freq lo
    ld a, CH1_FREQ & $FF
    ldh [rNR13], a
    ; Freq hi + Restart channel
    ld a, AUDHIGH_RESTART + (CH1_FREQ >> 8)
    ldh [rNR14], a

.play_channel_2
    ld a, b
    and a, INPUT_RIGHT
    jr z, .play_channel_3

    DEF CH2_ENV_INIT EQU 12
    DEF CH2_ENV_STEP EQU 4
    DEF CH2_FREQ     EQU $480

    ; Wave pattern duty
    ld a, AUDLEN_DUTY_25
    ldh [rNR21], a
    ; Volume envelope
    ld a, (CH2_ENV_INIT << 4) + AUDENV_DOWN + CH2_ENV_STEP
    ldh [rNR22], a
    ; Freq lo
    ld a, CH2_FREQ & $ff
    ldh [rNR23], a
    ; Freq hi + Restart channel
    ld a, AUDHIGH_RESTART + (CH2_FREQ >> 8)
    ldh [rNR24], a

.play_channel_3
    ld a, b
    and a, INPUT_UP
    jr z, .play_channel_4

    DEF CH3_LENGTH EQU 256
    DEF CH3_FREQ   EQU 1750  ; 131072 / (2048 - 1750) = 440Hz

    ; Enable playback
    ld a, $80
    ldh [rNR30], a
    ; Sound length
    ld a, 256 - CH3_LENGTH
    ldh [rNR31], a
    ; Output level
    ld a, %01 << 5
    ldh [rNR32], a
    ; Freq lo
    ld a, CH3_FREQ & $FF
    ldh [rNR33], a
    ; Freq hi + Restart channel
    ld a, AUDHIGH_RESTART + AUDHIGH_LENGTH_ON + (CH3_FREQ >> 8)
    ldh [rNR34], a

.play_channel_4
    ld a, b
    and a, INPUT_DOWN
    jr z, .end
    
    DEF CH4_ENV_INIT    EQU 12
    DEF CH4_ENV_STEP    EQU 4
    DEF CH4_SHIFT_FREQ  EQU 4
    DEF CH4_FREQ_RATIO  EQU 2

    ; Volume envelope
    ld a, (CH4_ENV_INIT << 4) + AUDENV_DOWN + CH4_ENV_STEP
    ldh [rNR42], a
    ; Polynomial Counter
    ld a, (CH4_SHIFT_FREQ << 4) + CH4_FREQ_RATIO
    ldh [rNR43], a
    ; Restart channel
    ld a, AUDHIGH_RESTART
    ldh [rNR44], a

.end
    ret

; How many times joystick inputs are read in a row.
; Common GB practice to make inputs values stable.
DEF INPUT_BOUNCE EQU 4

ReadInput:
    ; Read pad values
    ld a, ~ P1F_GET_DPAD
    ldh [rP1], a
    REPT INPUT_BOUNCE
    ldh a, [rP1]
    ENDR

    ; Move pad values to upper 4 bits, store in B
    and a, $0f
    swap a
    ld b, a

    ; Read button values
    ld a, ~ P1F_GET_BTN
    ldh [rP1], a
    REPT INPUT_BOUNCE
    ldh a, [rP1]
    ENDR

    ; Keep button values in lower 4 bits, combine with pad values
    and a, $0f
    or a, b
    ; Complement so that 1 = button pressed
    cpl 

    ; Store new inputs in B, copy previous inputs in C
    ld b, a
    ldh a, [hINPUT.now]
    ld c, a

    ; Compute new (up) presses
    xor a, b    ; Differences between new and previous
    and a, b    ; Keep only new inputs
    ldh [hINPUT.up], a

    ; Store new inputs as current inputs
    ld a, b
    ldh [hINPUT.now], a

    ret


SECTION "HRAM", HRAM

; Joystick input registers. A bit set is a button pressed.  
; From 7 to 0: Start, Select, B, A, Down, Up, Left, Right
hINPUT:

DEF INPUT_START  EQU %10000000
DEF INPUT_SELECT EQU %01000000
DEF INPUT_B      EQU %00100000
DEF INPUT_A      EQU %00010000
DEF INPUT_DOWN   EQU %00001000
DEF INPUT_UP     EQU %00000100
DEF INPUT_LEFT   EQU %00000010
DEF INPUT_RIGHT  EQU %00000001

; Holds the last value of all inputs.
.now
    ds 1
; Inputs that have been enabled since last frame
.up:
    ds 1
