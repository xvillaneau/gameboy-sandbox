
include "hardware.inc"


SECTION "Header", ROM0[$0000]
    ; Mostly blank space reserved for someday

    ; rst $00
    ds $08 - @, $00
    ; rst $08
    ds $10 - @, $00
    ; rst $10
    ds $18 - @, $00
    ; rst $18
    ds $20 - @, $00
    ; rst $20
    ds $28 - @, $00
    ; rst $28
    ds $30 - @, $00
    ; rst $30
    ds $38 - @, $00
    ; rst $38
    ds $40 - @, $00

    ; V-Blank interrupt
    reti
    ds $48 - @, $00

    ; LCDC interrupt
    reti
    ds $50 - @, $00

    ; Timer interrupt
    reti
    ds $58 - @, $00

    ; Serial Com interrupt
    reti
    ds $60 - @, $00

    ; Joypad interrupt
    reti
    ds $0100 - @, $00

EntryPoint:
    nop
    jp Init
    ; Make space for ROM header
    ; Will be generated by rgbfix at the end
    ds $0150 - @, $00


SECTION "Main", ROM0

Init:
    di
._sync
    ; Wait for the vertical blanking interval so that we can disable the LCD.
    ldh a, [rLY]
    cp 144              ; Wait for first frame to draw
    jr c, ._sync        ; carry unset => V-Blank started

    xor a
    ldh [rLCDC], a      ; Disable LCD Controller to access VRAM

    call InitSound

    ; Core loop of the program. All this does is wait for the next interrupt.
    ld a, LCDCF_ON
    ldh [rLCDC], a

    ld a, 1
    ldh [rIE], a        ; Enable VBlank interrupts handling
    ei                  ; Enable interrupts

.loop:
    halt                ; Stop CPU until next interupt
    ; There needs to be a NOP after HALT, rgbasm does that for us
    call ReadInput
    call PlaySound
    jr .loop            ; Loop forever


; Reset all sound settings
InitSound:
    ; Disable then re-enable sound. This resets all sound registers
    xor a
    ldh [rNR52], a
    ld a, AUDENA_ON
    ldh [rNR52], a

    ; Configure global sound options:
    ld a, $ff           ; Enable all channels and terminals
    ldh [rNR51], a
    ld a, $77           ; Both terminals at max volume
    ld [rNR50], a
    ret


; Play sound on input
PlaySound:
    ldh a, [hINPUT.up]
    ld b, a

    and a, INPUT_SELECT
    jr z, .play_channel_1
    ; Press select -> stop all sounds NOW
    call InitSound
    ret

.play_channel_1
    ; Left => Channel 1 tone with some frequency shift
    ld a, b
    and a, INPUT_LEFT
    jr z, .play_channel_2

    DEF CH1_SWEEP_TIME   EQU %101  ; 1 step = 39.1ms (5/128 Hz)
    DEF CH1_SWEEP_SHIFT  EQU %111  ; -1/128th freq/shift
    DEF CH1_ENV_INIT     EQU 15    ; Max volume
    DEF CH1_ENV_STEP     EQU 5     ; 1 step = 78.1ms (5/64 Hz)
    DEF CH1_FREQ         EQU 1750  ; 131072 / (2048 - 1750) = 440Hz

    ; Frequency sweep
    ld a, (CH1_SWEEP_TIME << 4) + AUD1SWEEP_DOWN + CH1_SWEEP_SHIFT
    ld [rNR10], a
    ; Wave pattern duty
    ld a, AUDLEN_DUTY_50
    ldh [rNR11], a
    ; Volume envelope
    ld a, (CH1_ENV_INIT << 4) + AUDENV_DOWN + CH1_ENV_STEP
    ldh [rNR12], a
    ; Freq lo
    ld a, CH1_FREQ & $FF
    ldh [rNR13], a
    ; Freq hi + Restart channel
    ld a, AUDHIGH_RESTART + (CH1_FREQ >> 8)
    ldh [rNR14], a

.play_channel_2
    ld a, b
    and a, INPUT_RIGHT
    jr z, .play_channel_3
    ; Wave pattern duty
    ld a, AUDLEN_DUTY_25
    ldh [rNR21], a
    ; Volume envelope
    ld a, ($c << 4) + AUDENV_DOWN + 4
    ldh [rNR22], a
    ; Freq lo
    ld a, $80
    ldh [rNR23], a
    ; Freq hi + Restart channel
    ld a, AUDHIGH_RESTART + 4
    ldh [rNR24], a

.play_channel_3
    ld a, b
    and a, INPUT_UP
    jr z, .play_channel_4
    ; TODO

.play_channel_4
    ld a, b
    and a, INPUT_DOWN
    jr z, .end
    ; TODO

.end
    ret

; How many times joystick inputs are read in a row.
; Common GB practice to make inputs values stable.
DEF INPUT_BOUNCE EQU 4

ReadInput:
    ; Read pad values
    ld a, ~ P1F_GET_DPAD
    ldh [rP1], a
    REPT INPUT_BOUNCE
    ldh a, [rP1]
    ENDR

    ; Move pad values to upper 4 bits, store in B
    and a, $0f
    swap a
    ld b, a

    ; Read button values
    ld a, ~ P1F_GET_BTN
    ldh [rP1], a
    REPT INPUT_BOUNCE
    ldh a, [rP1]
    ENDR

    ; Keep button values in lower 4 bits, combine with pad values
    and a, $0f
    or a, b
    ; Complement so that 1 = button pressed
    cpl 

    ; Store new inputs in B, copy previous inputs in C
    ld b, a
    ldh a, [hINPUT.now]
    ld c, a

    ; Compute new (up) presses
    xor a, b    ; Differences between new and previous
    and a, b    ; Keep only new inputs
    ldh [hINPUT.up], a

    ; Store new inputs as current inputs
    ld a, b
    ldh [hINPUT.now], a

    ret


SECTION "HRAM", HRAM

; Joystick input registers. A bit set is a button pressed.  
; From 7 to 0: Start, Select, B, A, Down, Up, Left, Right
hINPUT:

DEF INPUT_START  EQU %10000000
DEF INPUT_SELECT EQU %01000000
DEF INPUT_B      EQU %00100000
DEF INPUT_A      EQU %00010000
DEF INPUT_DOWN   EQU %00001000
DEF INPUT_UP     EQU %00000100
DEF INPUT_LEFT   EQU %00000010
DEF INPUT_RIGHT  EQU %00000001

; Holds the last value of all inputs.
.now
    ds 1
; Inputs that have been enabled since last frame
.up:
    ds 1
